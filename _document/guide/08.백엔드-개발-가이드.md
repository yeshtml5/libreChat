# ë°±ì—”ë“œ ê°œë°œ ê°€ì´ë“œ

LibreChat ë°±ì—”ë“œ(Node.js/Express) ê°œë°œì„ ìœ„í•œ ì¢…í•©ì ì¸ ê°€ì´ë“œì…ë‹ˆë‹¤.

## ğŸ—ï¸ ë°±ì—”ë“œ ì•„í‚¤í…ì²˜ ê°œìš”

LibreChatì˜ ë°±ì—”ë“œëŠ” **Express.js** ê¸°ë°˜ìœ¼ë¡œ êµ¬ì¶•ë˜ì—ˆìœ¼ë©°, **LangChain**ì„ í™œìš©í•œ AI í†µí•© ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

### **í•µì‹¬ ê¸°ìˆ  ìŠ¤íƒ**
- **Runtime**: Node.js 18+ LTS
- **Framework**: Express.js 4.x
- **Database**: MongoDB (Mongoose ODM)
- **Search**: MeiliSearch
- **Cache**: Redis  
- **AI Integration**: LangChain
- **Authentication**: Passport.js
- **Testing**: Jest + Supertest
- **Package Manager**: Yarn Berry 4.9.4

## ğŸ“ ë°±ì—”ë“œ í´ë” êµ¬ì¡° ìƒì„¸ ë¶„ì„

```
api/
â”œâ”€â”€ ğŸ“ app/                     # ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œì§ ë ˆì´ì–´
â”‚   â”œâ”€â”€ ğŸ“ clients/            # AI ì œê³µì—…ì²´ í´ë¼ì´ì–¸íŠ¸ë“¤
â”‚   â”‚   â”œâ”€â”€ AnthropicClient.js     # Claude ì—°ë™
â”‚   â”‚   â”œâ”€â”€ OpenAIClient.js        # GPT ì—°ë™  
â”‚   â”‚   â”œâ”€â”€ GoogleClient.js        # Gemini ì—°ë™
â”‚   â”‚   â”œâ”€â”€ BaseClient.js          # ì¶”ìƒ í´ë˜ìŠ¤
â”‚   â”‚   â”œâ”€â”€ ğŸ“ agents/            # LangChain ì—ì´ì „íŠ¸
â”‚   â”‚   â”œâ”€â”€ ğŸ“ tools/             # AI ë„êµ¬ë“¤
â”‚   â”‚   â”œâ”€â”€ ğŸ“ chains/            # LangChain ì²´ì¸
â”‚   â”‚   â”œâ”€â”€ ğŸ“ memory/            # ëŒ€í™” ë©”ëª¨ë¦¬ ê´€ë¦¬
â”‚   â”‚   â””â”€â”€ ğŸ“ prompts/           # í”„ë¡¬í”„íŠ¸ ê´€ë¦¬
â”‚   â””â”€â”€ index.js                   # App ë ˆì´ì–´ ì§„ì…ì 
â”‚   
â”œâ”€â”€ ğŸ“ server/                  # Express ì„œë²„ ë ˆì´ì–´
â”‚   â”œâ”€â”€ ğŸ“ controllers/        # HTTP ìš”ì²­ ì²˜ë¦¬
â”‚   â”‚   â”œâ”€â”€ AuthController.js      # ì¸ì¦ ë¡œì§
â”‚   â”‚   â”œâ”€â”€ ModelController.js     # AI ëª¨ë¸ ê´€ë¦¬
â”‚   â”‚   â”œâ”€â”€ EndpointController.js  # ì—”ë“œí¬ì¸íŠ¸ ì„¤ì •
â”‚   â”‚   â”œâ”€â”€ ğŸ“ agents/            # ì—ì´ì „íŠ¸ ì»¨íŠ¸ë¡¤ëŸ¬
â”‚   â”‚   â””â”€â”€ ğŸ“ assistants/        # OpenAI Assistants
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ middleware/         # Express ë¯¸ë“¤ì›¨ì–´
â”‚   â”‚   â”œâ”€â”€ requireJwtAuth.js      # JWT ì¸ì¦
â”‚   â”‚   â”œâ”€â”€ validateMessageReq.js  # ë©”ì‹œì§€ ê²€ì¦
â”‚   â”‚   â”œâ”€â”€ ğŸ“ limiters/          # Rate limiting
â”‚   â”‚   â””â”€â”€ ğŸ“ roles/             # ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ routes/             # API ë¼ìš°íŠ¸ ì •ì˜
â”‚   â”‚   â”œâ”€â”€ auth.js               # ì¸ì¦ ë¼ìš°íŠ¸
â”‚   â”‚   â”œâ”€â”€ messages.js           # ë©”ì‹œì§€ API
â”‚   â”‚   â”œâ”€â”€ convos.js            # ëŒ€í™” ê´€ë¦¬
â”‚   â”‚   â”œâ”€â”€ files.js             # íŒŒì¼ ì—…ë¡œë“œ
â”‚   â”‚   â”œâ”€â”€ ğŸ“ agents/           # ì—ì´ì „íŠ¸ ë¼ìš°íŠ¸
â”‚   â”‚   â””â”€â”€ ğŸ“ assistants/       # ì–´ì‹œìŠ¤í„´íŠ¸ ë¼ìš°íŠ¸
â”‚   â”‚
â”‚   â”œâ”€â”€ ğŸ“ services/           # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§
â”‚   â”‚   â”œâ”€â”€ AppService.js         # ì•± ì´ˆê¸°í™”
â”‚   â”‚   â”œâ”€â”€ AuthService.js        # ì¸ì¦ ì„œë¹„ìŠ¤
â”‚   â”‚   â”œâ”€â”€ ModelService.js       # ëª¨ë¸ ê´€ë¦¬
â”‚   â”‚   â”œâ”€â”€ ğŸ“ Config/           # ì„¤ì • ì„œë¹„ìŠ¤
â”‚   â”‚   â”œâ”€â”€ ğŸ“ Files/            # íŒŒì¼ ì²˜ë¦¬
â”‚   â”‚   â””â”€â”€ ğŸ“ Tools/            # ë„êµ¬ ê´€ë¦¬
â”‚   â”‚
â”‚   â””â”€â”€ index.js               # ì„œë²„ ì§„ì…ì 
â”‚   
â”œâ”€â”€ ğŸ“ models/                 # MongoDB ìŠ¤í‚¤ë§ˆ
â”‚   â”œâ”€â”€ Conversation.js           # ëŒ€í™” ëª¨ë¸
â”‚   â”œâ”€â”€ Message.js               # ë©”ì‹œì§€ ëª¨ë¸  
â”‚   â”œâ”€â”€ User.js                  # ì‚¬ìš©ì ëª¨ë¸
â”‚   â”œâ”€â”€ File.js                  # íŒŒì¼ ëª¨ë¸
â”‚   â””â”€â”€ Agent.js                 # ì—ì´ì „íŠ¸ ëª¨ë¸
â”‚   
â”œâ”€â”€ ğŸ“ strategies/             # Passport.js ì¸ì¦ ì „ëµ
â”‚   â”œâ”€â”€ jwtStrategy.js           # JWT ì¸ì¦
â”‚   â”œâ”€â”€ localStrategy.js         # ë¡œì»¬ ë¡œê·¸ì¸
â”‚   â”œâ”€â”€ googleStrategy.js        # Google OAuth
â”‚   â””â”€â”€ ldapStrategy.js          # LDAP ì¸ì¦
â”‚   
â”œâ”€â”€ ğŸ“ utils/                  # ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
â”‚   â”œâ”€â”€ logger.js               # ë¡œê¹… ì‹œìŠ¤í…œ
â”‚   â”œâ”€â”€ tokens.js              # í† í° ê´€ë¦¬
â”‚   â””â”€â”€ ğŸ“ emails/             # ì´ë©”ì¼ í…œí”Œë¦¿
â”‚   
â””â”€â”€ ğŸ“ test/                   # í…ŒìŠ¤íŠ¸ ì½”ë“œ
    â”œâ”€â”€ ğŸ“ app/clients/        # í´ë¼ì´ì–¸íŠ¸ í…ŒìŠ¤íŠ¸
    â””â”€â”€ ğŸ“ server/services/    # ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸
```

## ğŸš€ ë°±ì—”ë“œ ê°œë°œ ì‹œì‘í•˜ê¸°

### **1. ê°œë°œ í™˜ê²½ ì„¤ì •**

```bash
# 1. ì˜ì¡´ì„± ì„¤ì¹˜ (Yarn Berry)
yarn install

# 2. í™˜ê²½ë³€ìˆ˜ ì„¤ì •
cp .env.example .env
# .env íŒŒì¼ì„ í¸ì§‘í•˜ì—¬ í•„ìš”í•œ ì„¤ì • ì¶”ê°€

# 3. í•„ìˆ˜ íŒ¨í‚¤ì§€ ë¹Œë“œ
yarn build:data-schemas     # ë°ì´í„° ëª¨ë¸ íƒ€ì…
yarn build:data-provider    # API í´ë¼ì´ì–¸íŠ¸
yarn build:api              # ë°±ì—”ë“œ ê³µí†µ ë¡œì§

# 4. ë°±ì—”ë“œ ê°œë°œ ì„œë²„ ì‹œì‘
yarn backend:dev            # nodemonìœ¼ë¡œ ìë™ ì¬ì‹œì‘
```

### **2. í™˜ê²½ë³€ìˆ˜ ì„¤ì • (.env)**

```bash
# ì„œë²„ ì„¤ì •
PORT=3080
HOST=localhost
NODE_ENV=development

# ë°ì´í„°ë² ì´ìŠ¤
MONGO_URI=mongodb://localhost:27017/LibreChat

# JWT ì‹œí¬ë¦¿
JWT_SECRET=your-super-secret-jwt-key
JWT_REFRESH_SECRET=your-refresh-secret

# AI API í‚¤ë“¤
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=sk-ant-...
GOOGLE_API_KEY=your-google-key

# ê²€ìƒ‰ (MeiliSearch)
MEILI_HOST=http://localhost:7700
MEILI_MASTER_KEY=your-meili-key

# ìºì‹œ (Redis) - ì„ íƒì‚¬í•­
REDIS_URI=redis://localhost:6379

# íŒŒì¼ ì—…ë¡œë“œ
FILE_UPLOAD_PATH=./uploads
MAX_FILE_SIZE=20971520  # 20MB
```

## ğŸ”§ ë°±ì—”ë“œ ê°œë°œ ì›Œí¬í”Œë¡œìš°

### **1. ìƒˆë¡œìš´ API ì—”ë“œí¬ì¸íŠ¸ ì¶”ê°€**

#### **Step 1: ë¼ìš°íŠ¸ ì •ì˜**
```javascript
// api/server/routes/myFeature.js
const express = require('express');
const { requireJwtAuth } = require('../middleware');
const { MyFeatureController } = require('../controllers');

const router = express.Router();

router.get('/', requireJwtAuth, MyFeatureController.getAll);
router.post('/', requireJwtAuth, MyFeatureController.create);
router.put('/:id', requireJwtAuth, MyFeatureController.update);
router.delete('/:id', requireJwtAuth, MyFeatureController.delete);

module.exports = router;
```

#### **Step 2: ì»¨íŠ¸ë¡¤ëŸ¬ êµ¬í˜„**
```javascript
// api/server/controllers/MyFeatureController.js
const { MyFeatureService } = require('../services');
const { logger } = require('@librechat/data-schemas');

const MyFeatureController = {
  async getAll(req, res) {
    try {
      const { user } = req;
      const features = await MyFeatureService.findByUser(user.id);
      
      res.json({
        success: true,
        data: features
      });
    } catch (error) {
      logger.error('Error fetching features:', error);
      res.status(500).json({
        success: false,
        message: 'Internal server error'
      });
    }
  },

  async create(req, res) {
    try {
      const { user } = req;
      const featureData = req.body;
      
      const newFeature = await MyFeatureService.create({
        ...featureData,
        userId: user.id
      });
      
      res.status(201).json({
        success: true,
        data: newFeature
      });
    } catch (error) {
      logger.error('Error creating feature:', error);
      res.status(500).json({
        success: false,
        message: error.message
      });
    }
  }
};

module.exports = MyFeatureController;
```

#### **Step 3: ì„œë¹„ìŠ¤ ë ˆì´ì–´ êµ¬í˜„**
```javascript
// api/server/services/MyFeatureService.js
const { MyFeature } = require('~/models');

const MyFeatureService = {
  async findByUser(userId) {
    return await MyFeature.find({ userId }).lean();
  },

  async create(featureData) {
    const feature = new MyFeature(featureData);
    return await feature.save();
  },

  async update(id, updateData) {
    return await MyFeature.findByIdAndUpdate(
      id, 
      updateData, 
      { new: true }
    ).lean();
  },

  async delete(id) {
    return await MyFeature.findByIdAndDelete(id);
  }
};

module.exports = MyFeatureService;
```

#### **Step 4: MongoDB ëª¨ë¸ ì •ì˜**
```javascript
// api/models/MyFeature.js
const mongoose = require('mongoose');

const myFeatureSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true,
    maxlength: 100
  },
  description: {
    type: String,
    maxlength: 500
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  isActive: {
    type: Boolean,
    default: true
  },
  metadata: {
    type: mongoose.Schema.Types.Mixed
  }
}, {
  timestamps: true,
  collection: 'myfeatures'
});

// ì¸ë±ìŠ¤ ì„¤ì •
myFeatureSchema.index({ userId: 1, createdAt: -1 });

module.exports = mongoose.model('MyFeature', myFeatureSchema);
```

#### **Step 5: ë¼ìš°íŠ¸ ë“±ë¡**
```javascript
// api/server/index.jsì— ì¶”ê°€
const myFeatureRoutes = require('./routes/myFeature');

// API ë¼ìš°íŠ¸ ë“±ë¡
app.use('/api/my-feature', myFeatureRoutes);
```

### **2. AI í´ë¼ì´ì–¸íŠ¸ í†µí•©**

#### **ìƒˆë¡œìš´ AI ì œê³µì—…ì²´ ì¶”ê°€**
```javascript
// api/app/clients/CustomAIClient.js
const { BaseClient } = require('./BaseClient');

class CustomAIClient extends BaseClient {
  constructor(apiKey, options = {}) {
    super(apiKey, options);
    this.sender = 'CustomAI';
    this.apiKey = apiKey;
    this.baseURL = 'https://api.customai.com/v1';
  }

  async sendMessage(text, parentMessageId = null) {
    const { onProgress, abortController } = this;
    
    try {
      const response = await fetch(`${this.baseURL}/chat/completions`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: this.modelOptions.model,
          messages: this.getMessages(),
          stream: true,
          max_tokens: this.maxResponseTokens
        }),
        signal: abortController?.signal
      });

      return await this.handleStreamResponse(response, onProgress);
    } catch (error) {
      throw new Error(`CustomAI API Error: ${error.message}`);
    }
  }

  getMessages() {
    // ë©”ì‹œì§€ í¬ë§· ë³€í™˜ ë¡œì§
    return this.currentMessages.map(msg => ({
      role: msg.role,
      content: msg.content
    }));
  }
}

module.exports = CustomAIClient;
```

### **3. ë¯¸ë“¤ì›¨ì–´ ê°œë°œ**

#### **ì»¤ìŠ¤í…€ ê²€ì¦ ë¯¸ë“¤ì›¨ì–´**
```javascript
// api/server/middleware/validateMyFeature.js
const { body, validationResult } = require('express-validator');

const validateMyFeature = [
  body('title')
    .notEmpty()
    .withMessage('Title is required')
    .isLength({ max: 100 })
    .withMessage('Title must be less than 100 characters'),
    
  body('description')
    .optional()
    .isLength({ max: 500 })
    .withMessage('Description must be less than 500 characters'),
    
  body('isActive')
    .optional()
    .isBoolean()
    .withMessage('isActive must be a boolean'),

  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: errors.array()
      });
    }
    next();
  }
];

module.exports = validateMyFeature;
```

## ğŸ§ª ë°±ì—”ë“œ í…ŒìŠ¤íŠ¸

### **1. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±**

```javascript
// api/test/server/services/MyFeatureService.test.js
const { MyFeatureService } = require('../../../server/services');
const { MyFeature } = require('../../../models');

describe('MyFeatureService', () => {
  beforeEach(async () => {
    await MyFeature.deleteMany({});
  });

  describe('create', () => {
    it('should create a new feature', async () => {
      const featureData = {
        title: 'Test Feature',
        description: 'Test Description',
        userId: 'user123'
      };

      const result = await MyFeatureService.create(featureData);

      expect(result.title).toBe(featureData.title);
      expect(result.userId).toBe(featureData.userId);
    });

    it('should throw error for invalid data', async () => {
      const featureData = {
        // title ëˆ„ë½
        description: 'Test Description',
        userId: 'user123'
      };

      await expect(MyFeatureService.create(featureData))
        .rejects
        .toThrow();
    });
  });

  describe('findByUser', () => {
    it('should return features for user', async () => {
      const userId = 'user123';
      await MyFeature.create({
        title: 'Feature 1',
        userId: userId
      });
      await MyFeature.create({
        title: 'Feature 2',
        userId: userId
      });

      const results = await MyFeatureService.findByUser(userId);

      expect(results).toHaveLength(2);
      expect(results[0].userId).toBe(userId);
    });
  });
});
```

### **2. í†µí•© í…ŒìŠ¤íŠ¸**

```javascript
// api/test/server/routes/myFeature.test.js
const request = require('supertest');
const app = require('../../server');
const { connectDb } = require('~/db');

describe('/api/my-feature', () => {
  let authToken;
  let userId;

  beforeAll(async () => {
    await connectDb();
    
    // í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì ë¡œê·¸ì¸ìœ¼ë¡œ í† í° íšë“
    const loginResponse = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'test@example.com',
        password: 'testpassword'
      });
    
    authToken = loginResponse.body.token;
    userId = loginResponse.body.user.id;
  });

  describe('POST /api/my-feature', () => {
    it('should create a new feature', async () => {
      const featureData = {
        title: 'Test Feature',
        description: 'Test Description'
      };

      const response = await request(app)
        .post('/api/my-feature')
        .set('Authorization', `Bearer ${authToken}`)
        .send(featureData)
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.title).toBe(featureData.title);
    });

    it('should return 401 without auth', async () => {
      const featureData = {
        title: 'Test Feature'
      };

      await request(app)
        .post('/api/my-feature')
        .send(featureData)
        .expect(401);
    });
  });
});
```

## ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬

### **1. MongoDB ì—°ê²° ì„¤ì •**

```javascript
// api/db/connect.js (ì´ë¯¸ ì¡´ì¬)
const mongoose = require('mongoose');
const { logger } = require('@librechat/data-schemas');

const connectDb = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    
    logger.info('Connected to MongoDB');
  } catch (error) {
    logger.error('MongoDB connection error:', error);
    process.exit(1);
  }
};

module.exports = { connectDb };
```

### **2. ë°ì´í„° ë§ˆì´ê·¸ë ˆì´ì…˜**

```javascript
// api/migrations/001-add-myfeature-index.js
const { MyFeature } = require('../models');

const migration = {
  async up() {
    // ì¸ë±ìŠ¤ ì¶”ê°€
    await MyFeature.collection.createIndex({ 
      userId: 1, 
      createdAt: -1 
    });
    
    console.log('Added index to MyFeature collection');
  },

  async down() {
    // ë¡¤ë°± ë¡œì§
    await MyFeature.collection.dropIndex({ 
      userId: 1, 
      createdAt: -1 
    });
    
    console.log('Removed index from MyFeature collection');
  }
};

module.exports = migration;
```

## ğŸ”’ ë³´ì•ˆ ë° ì¸ì¦

### **1. JWT ë¯¸ë“¤ì›¨ì–´ í™œìš©**

```javascript
// ê¸°ì¡´ ë¯¸ë“¤ì›¨ì–´ ì‚¬ìš©
const { requireJwtAuth } = require('../middleware');

// ì„ íƒì  ì¸ì¦
const { optionalJwtAuth } = require('../middleware');

// ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´
const { requireRole } = require('../middleware/roles');

// ì‚¬ìš© ì˜ˆì‹œ
router.get('/admin', requireJwtAuth, requireRole('admin'), controller.adminOnly);
router.get('/public', optionalJwtAuth, controller.publicEndpoint);
```

### **2. Rate Limiting**

```javascript
// api/server/middleware/customLimiter.js
const rateLimit = require('express-rate-limit');
const { getLogStores } = require('~/cache');

const createCustomLimiter = (options = {}) => {
  const {
    windowMs = 15 * 60 * 1000, // 15ë¶„
    max = 100, // ìµœëŒ€ ìš”ì²­ ìˆ˜
    message = 'Too many requests'
  } = options;

  return rateLimit({
    windowMs,
    max,
    message: { error: message },
    standardHeaders: true,
    legacyHeaders: false,
    store: getLogStores().violationStore // Redis store ì‚¬ìš©
  });
};

module.exports = { createCustomLimiter };
```

## ğŸ“Š ë¡œê¹… ë° ëª¨ë‹ˆí„°ë§

### **1. êµ¬ì¡°í™”ëœ ë¡œê¹…**

```javascript
// api/utils/logger.js (ê¸°ì¡´ í™œìš©)
const { logger } = require('@librechat/data-schemas');

// ì‚¬ìš© ì˜ˆì‹œ
logger.info('User created successfully', {
  userId: user.id,
  email: user.email,
  ip: req.ip
});

logger.error('Database error', {
  error: error.message,
  stack: error.stack,
  query: queryData
});

logger.warn('Rate limit exceeded', {
  userId: user.id,
  endpoint: req.path,
  ip: req.ip
});
```

## ğŸ”„ ë°±ì—”ë“œ ê°œë°œ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

### **1. ì—ëŸ¬ í•¸ë“¤ë§**

```javascript
// api/server/middleware/errorHandler.js
const errorHandler = (err, req, res, next) => {
  logger.error('Unhandled error:', {
    error: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    userId: req.user?.id
  });

  // MongoDB ì¤‘ë³µ í‚¤ ì—ëŸ¬
  if (err.code === 11000) {
    return res.status(400).json({
      success: false,
      message: 'Duplicate entry'
    });
  }

  // Validation ì—ëŸ¬
  if (err.name === 'ValidationError') {
    const errors = Object.values(err.errors).map(e => e.message);
    return res.status(400).json({
      success: false,
      message: 'Validation error',
      errors
    });
  }

  // JWT ì—ëŸ¬
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({
      success: false,
      message: 'Invalid token'
    });
  }

  // ê¸°ë³¸ ì—ëŸ¬
  res.status(500).json({
    success: false,
    message: 'Internal server error'
  });
};

module.exports = errorHandler;
```

### **2. ì‘ë‹µ í‘œì¤€í™”**

```javascript
// api/utils/responseHelper.js
const sendSuccess = (res, data, message = 'Success', statusCode = 200) => {
  res.status(statusCode).json({
    success: true,
    message,
    data,
    timestamp: new Date().toISOString()
  });
};

const sendError = (res, message, statusCode = 400, errors = null) => {
  res.status(statusCode).json({
    success: false,
    message,
    errors,
    timestamp: new Date().toISOString()
  });
};

module.exports = { sendSuccess, sendError };
```

## ğŸš€ ë°±ì—”ë“œ ì„±ëŠ¥ ìµœì í™”

### **1. ë°ì´í„°ë² ì´ìŠ¤ ìµœì í™”**

```javascript
// ì¸ë±ìŠ¤ ìµœì í™”
userSchema.index({ email: 1 }, { unique: true });
messageSchema.index({ conversationId: 1, createdAt: -1 });
conversationSchema.index({ userId: 1, updatedAt: -1 });

// ì§‘ê³„ íŒŒì´í”„ë¼ì¸ ìµœì í™”
const getConversationStats = async (userId) => {
  return await Conversation.aggregate([
    { $match: { userId: new ObjectId(userId) } },
    { $group: {
        _id: null,
        totalConversations: { $sum: 1 },
        avgMessages: { $avg: '$messageCount' }
      }
    }
  ]);
};
```

### **2. ìºì‹± ì „ëµ**

```javascript
// api/cache/conversationCache.js
const { getLogStores } = require('~/cache');
const redis = getLogStores().cache;

const ConversationCache = {
  async getConversation(conversationId) {
    const key = `conv:${conversationId}`;
    const cached = await redis.get(key);
    
    if (cached) {
      return JSON.parse(cached);
    }
    
    const conversation = await Conversation.findById(conversationId);
    if (conversation) {
      await redis.setex(key, 300, JSON.stringify(conversation)); // 5ë¶„ ìºì‹œ
    }
    
    return conversation;
  },

  async invalidateConversation(conversationId) {
    const key = `conv:${conversationId}`;
    await redis.del(key);
  }
};

module.exports = ConversationCache;
```

ì´ì œ LibreChat ë°±ì—”ë“œì˜ ì „ì²´ì ì¸ êµ¬ì¡°ì™€ ê°œë°œ ë°©ë²•ì„ ì´í•´í•  ìˆ˜ ìˆì„ ê²ƒì…ë‹ˆë‹¤. ì¶”ê°€ë¡œ ê¶ê¸ˆí•œ ë¶€ë¶„ì´ ìˆìœ¼ë©´ ì–¸ì œë“  ë¬¼ì–´ë³´ì„¸ìš”!