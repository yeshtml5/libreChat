# 백엔드 개발 가이드

LibreChat 백엔드(Node.js/Express) 개발을 위한 종합적인 가이드입니다.

## 🏗️ 백엔드 아키텍처 개요

LibreChat의 백엔드는 **Express.js** 기반으로 구축되었으며, **LangChain**을 활용한 AI 통합 시스템입니다.

### **핵심 기술 스택**
- **Runtime**: Node.js 18+ LTS
- **Framework**: Express.js 4.x
- **Database**: MongoDB (Mongoose ODM)
- **Search**: MeiliSearch
- **Cache**: Redis  
- **AI Integration**: LangChain
- **Authentication**: Passport.js
- **Testing**: Jest + Supertest
- **Package Manager**: Yarn Berry 4.9.4

## 📁 백엔드 폴더 구조 상세 분석

```
api/
├── 📁 app/                     # 애플리케이션 로직 레이어
│   ├── 📁 clients/            # AI 제공업체 클라이언트들
│   │   ├── AnthropicClient.js     # Claude 연동
│   │   ├── OpenAIClient.js        # GPT 연동  
│   │   ├── GoogleClient.js        # Gemini 연동
│   │   ├── BaseClient.js          # 추상 클래스
│   │   ├── 📁 agents/            # LangChain 에이전트
│   │   ├── 📁 tools/             # AI 도구들
│   │   ├── 📁 chains/            # LangChain 체인
│   │   ├── 📁 memory/            # 대화 메모리 관리
│   │   └── 📁 prompts/           # 프롬프트 관리
│   └── index.js                   # App 레이어 진입점
│   
├── 📁 server/                  # Express 서버 레이어
│   ├── 📁 controllers/        # HTTP 요청 처리
│   │   ├── AuthController.js      # 인증 로직
│   │   ├── ModelController.js     # AI 모델 관리
│   │   ├── EndpointController.js  # 엔드포인트 설정
│   │   ├── 📁 agents/            # 에이전트 컨트롤러
│   │   └── 📁 assistants/        # OpenAI Assistants
│   │
│   ├── 📁 middleware/         # Express 미들웨어
│   │   ├── requireJwtAuth.js      # JWT 인증
│   │   ├── validateMessageReq.js  # 메시지 검증
│   │   ├── 📁 limiters/          # Rate limiting
│   │   └── 📁 roles/             # 역할 기반 접근 제어
│   │
│   ├── 📁 routes/             # API 라우트 정의
│   │   ├── auth.js               # 인증 라우트
│   │   ├── messages.js           # 메시지 API
│   │   ├── convos.js            # 대화 관리
│   │   ├── files.js             # 파일 업로드
│   │   ├── 📁 agents/           # 에이전트 라우트
│   │   └── 📁 assistants/       # 어시스턴트 라우트
│   │
│   ├── 📁 services/           # 비즈니스 로직
│   │   ├── AppService.js         # 앱 초기화
│   │   ├── AuthService.js        # 인증 서비스
│   │   ├── ModelService.js       # 모델 관리
│   │   ├── 📁 Config/           # 설정 서비스
│   │   ├── 📁 Files/            # 파일 처리
│   │   └── 📁 Tools/            # 도구 관리
│   │
│   └── index.js               # 서버 진입점
│   
├── 📁 models/                 # MongoDB 스키마
│   ├── Conversation.js           # 대화 모델
│   ├── Message.js               # 메시지 모델  
│   ├── User.js                  # 사용자 모델
│   ├── File.js                  # 파일 모델
│   └── Agent.js                 # 에이전트 모델
│   
├── 📁 strategies/             # Passport.js 인증 전략
│   ├── jwtStrategy.js           # JWT 인증
│   ├── localStrategy.js         # 로컬 로그인
│   ├── googleStrategy.js        # Google OAuth
│   └── ldapStrategy.js          # LDAP 인증
│   
├── 📁 utils/                  # 유틸리티 함수
│   ├── logger.js               # 로깅 시스템
│   ├── tokens.js              # 토큰 관리
│   └── 📁 emails/             # 이메일 템플릿
│   
└── 📁 test/                   # 테스트 코드
    ├── 📁 app/clients/        # 클라이언트 테스트
    └── 📁 server/services/    # 서비스 테스트
```

## 🚀 백엔드 개발 시작하기

### **1. 개발 환경 설정**

```bash
# 1. 의존성 설치 (Yarn Berry)
yarn install

# 2. 환경변수 설정
cp .env.example .env
# .env 파일을 편집하여 필요한 설정 추가

# 3. 필수 패키지 빌드
yarn build:data-schemas     # 데이터 모델 타입
yarn build:data-provider    # API 클라이언트
yarn build:api              # 백엔드 공통 로직

# 4. 백엔드 개발 서버 시작
yarn backend:dev            # nodemon으로 자동 재시작
```

### **2. 환경변수 설정 (.env)**

```bash
# 서버 설정
PORT=3080
HOST=localhost
NODE_ENV=development

# 데이터베이스
MONGO_URI=mongodb://localhost:27017/LibreChat

# JWT 시크릿
JWT_SECRET=your-super-secret-jwt-key
JWT_REFRESH_SECRET=your-refresh-secret

# AI API 키들
OPENAI_API_KEY=sk-...
ANTHROPIC_API_KEY=sk-ant-...
GOOGLE_API_KEY=your-google-key

# 검색 (MeiliSearch)
MEILI_HOST=http://localhost:7700
MEILI_MASTER_KEY=your-meili-key

# 캐시 (Redis) - 선택사항
REDIS_URI=redis://localhost:6379

# 파일 업로드
FILE_UPLOAD_PATH=./uploads
MAX_FILE_SIZE=20971520  # 20MB
```

## 🔧 백엔드 개발 워크플로우

### **1. 새로운 API 엔드포인트 추가**

#### **Step 1: 라우트 정의**
```javascript
// api/server/routes/myFeature.js
const express = require('express');
const { requireJwtAuth } = require('../middleware');
const { MyFeatureController } = require('../controllers');

const router = express.Router();

router.get('/', requireJwtAuth, MyFeatureController.getAll);
router.post('/', requireJwtAuth, MyFeatureController.create);
router.put('/:id', requireJwtAuth, MyFeatureController.update);
router.delete('/:id', requireJwtAuth, MyFeatureController.delete);

module.exports = router;
```

#### **Step 2: 컨트롤러 구현**
```javascript
// api/server/controllers/MyFeatureController.js
const { MyFeatureService } = require('../services');
const { logger } = require('@librechat/data-schemas');

const MyFeatureController = {
  async getAll(req, res) {
    try {
      const { user } = req;
      const features = await MyFeatureService.findByUser(user.id);
      
      res.json({
        success: true,
        data: features
      });
    } catch (error) {
      logger.error('Error fetching features:', error);
      res.status(500).json({
        success: false,
        message: 'Internal server error'
      });
    }
  },

  async create(req, res) {
    try {
      const { user } = req;
      const featureData = req.body;
      
      const newFeature = await MyFeatureService.create({
        ...featureData,
        userId: user.id
      });
      
      res.status(201).json({
        success: true,
        data: newFeature
      });
    } catch (error) {
      logger.error('Error creating feature:', error);
      res.status(500).json({
        success: false,
        message: error.message
      });
    }
  }
};

module.exports = MyFeatureController;
```

#### **Step 3: 서비스 레이어 구현**
```javascript
// api/server/services/MyFeatureService.js
const { MyFeature } = require('~/models');

const MyFeatureService = {
  async findByUser(userId) {
    return await MyFeature.find({ userId }).lean();
  },

  async create(featureData) {
    const feature = new MyFeature(featureData);
    return await feature.save();
  },

  async update(id, updateData) {
    return await MyFeature.findByIdAndUpdate(
      id, 
      updateData, 
      { new: true }
    ).lean();
  },

  async delete(id) {
    return await MyFeature.findByIdAndDelete(id);
  }
};

module.exports = MyFeatureService;
```

#### **Step 4: MongoDB 모델 정의**
```javascript
// api/models/MyFeature.js
const mongoose = require('mongoose');

const myFeatureSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true,
    maxlength: 100
  },
  description: {
    type: String,
    maxlength: 500
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  isActive: {
    type: Boolean,
    default: true
  },
  metadata: {
    type: mongoose.Schema.Types.Mixed
  }
}, {
  timestamps: true,
  collection: 'myfeatures'
});

// 인덱스 설정
myFeatureSchema.index({ userId: 1, createdAt: -1 });

module.exports = mongoose.model('MyFeature', myFeatureSchema);
```

#### **Step 5: 라우트 등록**
```javascript
// api/server/index.js에 추가
const myFeatureRoutes = require('./routes/myFeature');

// API 라우트 등록
app.use('/api/my-feature', myFeatureRoutes);
```

### **2. AI 클라이언트 통합**

#### **새로운 AI 제공업체 추가**
```javascript
// api/app/clients/CustomAIClient.js
const { BaseClient } = require('./BaseClient');

class CustomAIClient extends BaseClient {
  constructor(apiKey, options = {}) {
    super(apiKey, options);
    this.sender = 'CustomAI';
    this.apiKey = apiKey;
    this.baseURL = 'https://api.customai.com/v1';
  }

  async sendMessage(text, parentMessageId = null) {
    const { onProgress, abortController } = this;
    
    try {
      const response = await fetch(`${this.baseURL}/chat/completions`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: this.modelOptions.model,
          messages: this.getMessages(),
          stream: true,
          max_tokens: this.maxResponseTokens
        }),
        signal: abortController?.signal
      });

      return await this.handleStreamResponse(response, onProgress);
    } catch (error) {
      throw new Error(`CustomAI API Error: ${error.message}`);
    }
  }

  getMessages() {
    // 메시지 포맷 변환 로직
    return this.currentMessages.map(msg => ({
      role: msg.role,
      content: msg.content
    }));
  }
}

module.exports = CustomAIClient;
```

### **3. 미들웨어 개발**

#### **커스텀 검증 미들웨어**
```javascript
// api/server/middleware/validateMyFeature.js
const { body, validationResult } = require('express-validator');

const validateMyFeature = [
  body('title')
    .notEmpty()
    .withMessage('Title is required')
    .isLength({ max: 100 })
    .withMessage('Title must be less than 100 characters'),
    
  body('description')
    .optional()
    .isLength({ max: 500 })
    .withMessage('Description must be less than 500 characters'),
    
  body('isActive')
    .optional()
    .isBoolean()
    .withMessage('isActive must be a boolean'),

  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        success: false,
        message: 'Validation error',
        errors: errors.array()
      });
    }
    next();
  }
];

module.exports = validateMyFeature;
```

## 🧪 백엔드 테스트

### **1. 단위 테스트 작성**

```javascript
// api/test/server/services/MyFeatureService.test.js
const { MyFeatureService } = require('../../../server/services');
const { MyFeature } = require('../../../models');

describe('MyFeatureService', () => {
  beforeEach(async () => {
    await MyFeature.deleteMany({});
  });

  describe('create', () => {
    it('should create a new feature', async () => {
      const featureData = {
        title: 'Test Feature',
        description: 'Test Description',
        userId: 'user123'
      };

      const result = await MyFeatureService.create(featureData);

      expect(result.title).toBe(featureData.title);
      expect(result.userId).toBe(featureData.userId);
    });

    it('should throw error for invalid data', async () => {
      const featureData = {
        // title 누락
        description: 'Test Description',
        userId: 'user123'
      };

      await expect(MyFeatureService.create(featureData))
        .rejects
        .toThrow();
    });
  });

  describe('findByUser', () => {
    it('should return features for user', async () => {
      const userId = 'user123';
      await MyFeature.create({
        title: 'Feature 1',
        userId: userId
      });
      await MyFeature.create({
        title: 'Feature 2',
        userId: userId
      });

      const results = await MyFeatureService.findByUser(userId);

      expect(results).toHaveLength(2);
      expect(results[0].userId).toBe(userId);
    });
  });
});
```

### **2. 통합 테스트**

```javascript
// api/test/server/routes/myFeature.test.js
const request = require('supertest');
const app = require('../../server');
const { connectDb } = require('~/db');

describe('/api/my-feature', () => {
  let authToken;
  let userId;

  beforeAll(async () => {
    await connectDb();
    
    // 테스트 사용자 로그인으로 토큰 획득
    const loginResponse = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'test@example.com',
        password: 'testpassword'
      });
    
    authToken = loginResponse.body.token;
    userId = loginResponse.body.user.id;
  });

  describe('POST /api/my-feature', () => {
    it('should create a new feature', async () => {
      const featureData = {
        title: 'Test Feature',
        description: 'Test Description'
      };

      const response = await request(app)
        .post('/api/my-feature')
        .set('Authorization', `Bearer ${authToken}`)
        .send(featureData)
        .expect(201);

      expect(response.body.success).toBe(true);
      expect(response.body.data.title).toBe(featureData.title);
    });

    it('should return 401 without auth', async () => {
      const featureData = {
        title: 'Test Feature'
      };

      await request(app)
        .post('/api/my-feature')
        .send(featureData)
        .expect(401);
    });
  });
});
```

## 🗄️ 데이터베이스 관리

### **1. MongoDB 연결 설정**

```javascript
// api/db/connect.js (이미 존재)
const mongoose = require('mongoose');
const { logger } = require('@librechat/data-schemas');

const connectDb = async () => {
  try {
    await mongoose.connect(process.env.MONGO_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    
    logger.info('Connected to MongoDB');
  } catch (error) {
    logger.error('MongoDB connection error:', error);
    process.exit(1);
  }
};

module.exports = { connectDb };
```

### **2. 데이터 마이그레이션**

```javascript
// api/migrations/001-add-myfeature-index.js
const { MyFeature } = require('../models');

const migration = {
  async up() {
    // 인덱스 추가
    await MyFeature.collection.createIndex({ 
      userId: 1, 
      createdAt: -1 
    });
    
    console.log('Added index to MyFeature collection');
  },

  async down() {
    // 롤백 로직
    await MyFeature.collection.dropIndex({ 
      userId: 1, 
      createdAt: -1 
    });
    
    console.log('Removed index from MyFeature collection');
  }
};

module.exports = migration;
```

## 🔒 보안 및 인증

### **1. JWT 미들웨어 활용**

```javascript
// 기존 미들웨어 사용
const { requireJwtAuth } = require('../middleware');

// 선택적 인증
const { optionalJwtAuth } = require('../middleware');

// 역할 기반 접근 제어
const { requireRole } = require('../middleware/roles');

// 사용 예시
router.get('/admin', requireJwtAuth, requireRole('admin'), controller.adminOnly);
router.get('/public', optionalJwtAuth, controller.publicEndpoint);
```

### **2. Rate Limiting**

```javascript
// api/server/middleware/customLimiter.js
const rateLimit = require('express-rate-limit');
const { getLogStores } = require('~/cache');

const createCustomLimiter = (options = {}) => {
  const {
    windowMs = 15 * 60 * 1000, // 15분
    max = 100, // 최대 요청 수
    message = 'Too many requests'
  } = options;

  return rateLimit({
    windowMs,
    max,
    message: { error: message },
    standardHeaders: true,
    legacyHeaders: false,
    store: getLogStores().violationStore // Redis store 사용
  });
};

module.exports = { createCustomLimiter };
```

## 📊 로깅 및 모니터링

### **1. 구조화된 로깅**

```javascript
// api/utils/logger.js (기존 활용)
const { logger } = require('@librechat/data-schemas');

// 사용 예시
logger.info('User created successfully', {
  userId: user.id,
  email: user.email,
  ip: req.ip
});

logger.error('Database error', {
  error: error.message,
  stack: error.stack,
  query: queryData
});

logger.warn('Rate limit exceeded', {
  userId: user.id,
  endpoint: req.path,
  ip: req.ip
});
```

## 🔄 백엔드 개발 베스트 프랙티스

### **1. 에러 핸들링**

```javascript
// api/server/middleware/errorHandler.js
const errorHandler = (err, req, res, next) => {
  logger.error('Unhandled error:', {
    error: err.message,
    stack: err.stack,
    url: req.url,
    method: req.method,
    userId: req.user?.id
  });

  // MongoDB 중복 키 에러
  if (err.code === 11000) {
    return res.status(400).json({
      success: false,
      message: 'Duplicate entry'
    });
  }

  // Validation 에러
  if (err.name === 'ValidationError') {
    const errors = Object.values(err.errors).map(e => e.message);
    return res.status(400).json({
      success: false,
      message: 'Validation error',
      errors
    });
  }

  // JWT 에러
  if (err.name === 'JsonWebTokenError') {
    return res.status(401).json({
      success: false,
      message: 'Invalid token'
    });
  }

  // 기본 에러
  res.status(500).json({
    success: false,
    message: 'Internal server error'
  });
};

module.exports = errorHandler;
```

### **2. 응답 표준화**

```javascript
// api/utils/responseHelper.js
const sendSuccess = (res, data, message = 'Success', statusCode = 200) => {
  res.status(statusCode).json({
    success: true,
    message,
    data,
    timestamp: new Date().toISOString()
  });
};

const sendError = (res, message, statusCode = 400, errors = null) => {
  res.status(statusCode).json({
    success: false,
    message,
    errors,
    timestamp: new Date().toISOString()
  });
};

module.exports = { sendSuccess, sendError };
```

## 🚀 백엔드 성능 최적화

### **1. 데이터베이스 최적화**

```javascript
// 인덱스 최적화
userSchema.index({ email: 1 }, { unique: true });
messageSchema.index({ conversationId: 1, createdAt: -1 });
conversationSchema.index({ userId: 1, updatedAt: -1 });

// 집계 파이프라인 최적화
const getConversationStats = async (userId) => {
  return await Conversation.aggregate([
    { $match: { userId: new ObjectId(userId) } },
    { $group: {
        _id: null,
        totalConversations: { $sum: 1 },
        avgMessages: { $avg: '$messageCount' }
      }
    }
  ]);
};
```

### **2. 캐싱 전략**

```javascript
// api/cache/conversationCache.js
const { getLogStores } = require('~/cache');
const redis = getLogStores().cache;

const ConversationCache = {
  async getConversation(conversationId) {
    const key = `conv:${conversationId}`;
    const cached = await redis.get(key);
    
    if (cached) {
      return JSON.parse(cached);
    }
    
    const conversation = await Conversation.findById(conversationId);
    if (conversation) {
      await redis.setex(key, 300, JSON.stringify(conversation)); // 5분 캐시
    }
    
    return conversation;
  },

  async invalidateConversation(conversationId) {
    const key = `conv:${conversationId}`;
    await redis.del(key);
  }
};

module.exports = ConversationCache;
```

이제 LibreChat 백엔드의 전체적인 구조와 개발 방법을 이해할 수 있을 것입니다. 추가로 궁금한 부분이 있으면 언제든 물어보세요!